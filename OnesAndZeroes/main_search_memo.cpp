#include <iostream>
#include <vector>
#include <string>
#include <cassert>
#include <unordered_map>

using namespace std;

static const auto _____ = []() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return nullptr;
}();

class Solution {
private:

    unordered_map<string, vector<int>> countMap;

    vector<unordered_map<string, int>> memoMN;

    vector<int> getZeroOneCount(string s) {
        if (countMap.count(s)) {
            return countMap[s];
        }

        int oneCount = 0, zeroCount = 0;
        for (int j = 0; j < s.size(); ++j) {
            int num = s[j] - '0';
            if (num == 1)
                oneCount++;
            else
                zeroCount++;
        }
        vector<int> result;
        result.push_back(zeroCount);
        result.push_back(oneCount);
        countMap[s] = result;

        return countMap[s];
    }

    vector<int> mn_toInt(string mn) {

        if (numberMap.count(mn)) {
            return numberMap[mn];
        }

        stringstream ss(mn);
        string segment;
        vector<int> seglist;

        while (getline(ss, segment, '_')) {
            stringstream geek(segment);
            int x = 0;
            geek >> x;
            seglist.push_back(x);
        }
        numberMap[mn] = seglist;
        return seglist;
    }

    int searchMaxDepth(vector<string> &strs, int index, int m, int n) {

        if (index < 0 || (m == 0 && n == 0) || m < 0 || n < 0)
            return 0;

        string curS = strs[index];

        string mn = to_string(m) + "_" + to_string(n);

//        unordered_map<string, int>::iterator it = memoMN[index].find(mn);
        auto it = memoMN[index].find(mn);
        if (it != memoMN[index].end()) {
            return memoMN[index][mn];
        }

        int res = searchMaxDepth(strs, index - 1, m, n);

        vector<int> counts = getZeroOneCount(curS);
        int zeroCount = counts[0];
        int oneCount = counts[1];

        if ((m - zeroCount) >= 0 && (n - oneCount) >= 0) {
            res = max(res, 1 + searchMaxDepth(strs, index - 1, m - zeroCount, n - oneCount));
        }

        memoMN[index][mn] = res;

        return memoMN[index][mn];
    }


public:
    int findMaxForm(vector<string> &strs, int m, int n) {


        memoMN = vector<unordered_map<string, int>>(strs.size() + 1, unordered_map<string, int>());
        memoMN.clear();

        countMap.clear();

        int res = 0;
        //
        res = max(res, searchMaxDepth(strs, strs.size() - 1, m, n));
        return res;

    }

};


int main() {
    vector<string> strs = {"1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101"};

    clock_t startTime = clock();
    Solution s;
    cout << s.findMaxForm(strs, 100, 100) << endl;
    clock_t endTime = clock();
    cout<<"cost time: " << double(endTime - startTime) / CLOCKS_PER_SEC;
    return 0;
}